// Generated by gencpp from file motoman_msgs/SelectToolRequest.msg
// DO NOT EDIT!


#ifndef MOTOMAN_MSGS_MESSAGE_SELECTTOOLREQUEST_H
#define MOTOMAN_MSGS_MESSAGE_SELECTTOOLREQUEST_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace motoman_msgs
{
template <class ContainerAllocator>
struct SelectToolRequest_
{
  typedef SelectToolRequest_<ContainerAllocator> Type;

  SelectToolRequest_()
    : group_number(0)
    , tool_number(0)  {
    }
  SelectToolRequest_(const ContainerAllocator& _alloc)
    : group_number(0)
    , tool_number(0)  {
  (void)_alloc;
    }



   typedef uint32_t _group_number_type;
  _group_number_type group_number;

   typedef uint32_t _tool_number_type;
  _tool_number_type tool_number;





  typedef boost::shared_ptr< ::motoman_msgs::SelectToolRequest_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::motoman_msgs::SelectToolRequest_<ContainerAllocator> const> ConstPtr;

}; // struct SelectToolRequest_

typedef ::motoman_msgs::SelectToolRequest_<std::allocator<void> > SelectToolRequest;

typedef boost::shared_ptr< ::motoman_msgs::SelectToolRequest > SelectToolRequestPtr;
typedef boost::shared_ptr< ::motoman_msgs::SelectToolRequest const> SelectToolRequestConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::motoman_msgs::SelectToolRequest_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::motoman_msgs::SelectToolRequest_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::motoman_msgs::SelectToolRequest_<ContainerAllocator1> & lhs, const ::motoman_msgs::SelectToolRequest_<ContainerAllocator2> & rhs)
{
  return lhs.group_number == rhs.group_number &&
    lhs.tool_number == rhs.tool_number;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::motoman_msgs::SelectToolRequest_<ContainerAllocator1> & lhs, const ::motoman_msgs::SelectToolRequest_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace motoman_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::motoman_msgs::SelectToolRequest_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::motoman_msgs::SelectToolRequest_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::motoman_msgs::SelectToolRequest_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::motoman_msgs::SelectToolRequest_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::motoman_msgs::SelectToolRequest_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::motoman_msgs::SelectToolRequest_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::motoman_msgs::SelectToolRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "fa612b76af0dfd1addb4c87693871b10";
  }

  static const char* value(const ::motoman_msgs::SelectToolRequest_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xfa612b76af0dfd1aULL;
  static const uint64_t static_value2 = 0xddb4c87693871b10ULL;
};

template<class ContainerAllocator>
struct DataType< ::motoman_msgs::SelectToolRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "motoman_msgs/SelectToolRequest";
  }

  static const char* value(const ::motoman_msgs::SelectToolRequest_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::motoman_msgs::SelectToolRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "\n"
"# Change the active tool file on the controller.\n"
"#\n"
"# This changes the tool definition used for both (Moto)ROS-controlled motions\n"
"# and manual jogging.\n"
"#\n"
"#\n"
"# ## Controller support\n"
"#\n"
"# This service wraps two distinct (but related) actions:\n"
"#\n"
"#  1. changing the tool file used for execution of (Moto)ROS-controlled motions\n"
"#  2. changing the tool file used for jogging\n"
"#\n"
"# Action 1 is supported by all controllers supported by MotoROS (ie: DX100,\n"
"# FS100, DX200 and YRC1000(u)).\n"
"#\n"
"# Action 2 is NOT supported on FS100 controllers. This is a limitation of\n"
"# MotoPlus, not of MotoROS.\n"
"#\n"
"# In all cases, make sure to read the following sections carefully to be aware\n"
"# of the behaviour of this service and of the Yaskawa controller after calling\n"
"# this service.\n"
"#\n"
"#\n"
"# ## FSU and PFL\n"
"#\n"
"# Tool switches through this service will be taken into account by the FSU and\n"
"# PFL safety systems if the controller has these options and they are enabled.\n"
"#\n"
"# Tool interference files, if associated with certain tool file definitions,\n"
"# will therefore also switch.\n"
"#\n"
"#\n"
"# ## Tool switch timing\n"
"#\n"
"# The active tool will be switched AFTER the controller has completed execution\n"
"# of the last trajectory segment that was sent to MotoROS BEFORE this service\n"
"# was called.\n"
"#\n"
"# The motion queue internal to MotoROS caches a number of segments in a FIFO.\n"
"# Only segments received AFTER this service was invoked will be executed with\n"
"# the new tool. Any segments received before a tool switch was invoked will use\n"
"# the old tool.\n"
"#\n"
"# To ensure motion will be executed using a certain tool, applications should\n"
"# check the 'in_motion' field (part of the RobotStatus message published on the\n"
"# 'robot_status' topic by the driver) and invoke the service when the robot has\n"
"# come to a stop (and the motion queue of MotoROS is empty). Any subsequent\n"
"# trajectories will use the new tool.\n"
"#\n"
"#\n"
"# ## Effect on trajectory execution\n"
"#\n"
"# As MotoROS currently only executes joint space trajectories, changing tool\n"
"# file with this service DOES NOT affect the execution of those trajectories.\n"
"#\n"
"# As noted earlier though, the active tool file definition will affect FSU and\n"
"# PFL behaviour, as the tool definition is used in calculation of dynamics and\n"
"# safety (see \"FSU and PFL\" above).\n"
"#\n"
"# To clarify: the TCP definition of the tool file is NOT taken into account when\n"
"# calculating manipulator motion based on incoming ROS JointTrajectoryAction\n"
"# goals (as JointTrajectory goals do not include any Cartesian poses, only\n"
"# absolute joint space coordinates for each axis).\n"
"#\n"
"# Instead, ROS applications should use different TF frames to define tool frames\n"
"# on the ROS side and plan their motions with the appropriate TF frame as the\n"
"# active tool.\n"
"#\n"
"# This service could then be used to notify the controller of other tool\n"
"# characteristics, such as weight, CoG and inertia by switching to a tool file\n"
"# configured with those parameters.\n"
"#\n"
"#\n"
"# ## Retrieving the active tool file\n"
"#\n"
"# MotoROS does not currently support retrieving the active tool file.\n"
"#\n"
"#\n"
"#\n"
"# For more information about tool file configuration, selection and use on\n"
"# Yaskawa controllers, refer to the relevant Yaskawa Motoman documentation.\n"
"\n"
"\n"
"# Numeric ID of the group the tool file is defined for.\n"
"#\n"
"# This MUST correspond to a group ID currently defined and active on the\n"
"# controller. The ROS service does not check whether the value specified here\n"
"# is legal. The MotoROS server will however check this, and will refuse to\n"
"# switch to an illegal value and will report this to the ROS driver.\n"
"#\n"
"# Callers will be notified of such failures by 'success' being set to 'false'\n"
"# and an appropriate error message being provided via the 'message' field of\n"
"# the service response.\n"
"#\n"
"# NOTE: this field is 0-based, with 0 corresponding to the first motion group,\n"
"#       1 the second, etc.\n"
"#\n"
"# legal-values: [0, total_nr_of_groups)\n"
"# required: yes (absence-causes-service-failure)\n"
"# default: no-default\n"
"uint32 group_number\n"
"\n"
"# Numeric ID of the tool file to switch to for the specified group.\n"
"#\n"
"# Identical to 'group_number', specification of illegal values will result\n"
"# in failure to invoke the MotoROS service, and an unsuccessful service result\n"
"# being returned.\n"
"#\n"
"# NOTE: this field is 0-based, with 0 corresponding to the first tool file,\n"
"#       1 the second, etc.\n"
"#\n"
"# legal-values: [0, 63]\n"
"# required: yes (absence-causes-service-failure)\n"
"# default: no-default\n"
"uint32 tool_number\n"
"\n"
"# TODO: might want to expose 'sequence_number' here as well\n"
"\n"
;
  }

  static const char* value(const ::motoman_msgs::SelectToolRequest_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::motoman_msgs::SelectToolRequest_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.group_number);
      stream.next(m.tool_number);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct SelectToolRequest_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::motoman_msgs::SelectToolRequest_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::motoman_msgs::SelectToolRequest_<ContainerAllocator>& v)
  {
    s << indent << "group_number: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.group_number);
    s << indent << "tool_number: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.tool_number);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MOTOMAN_MSGS_MESSAGE_SELECTTOOLREQUEST_H
